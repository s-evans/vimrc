==============================================================================

8.2 Functions for String Substitution and Analysis

Here are some functions that operate on strings:

$(*subst* from,to,text)

    Performs a textual replacement on the text text: each occurrence of from is
    replaced by to. The result is substituted for the function call. For
    example,

    $(|subst| ee,EE,feet on the street)

    substitutes the string ‘fEEt on the strEEt’.

$(*patsubst* pattern,replacement,text)

    Finds whitespace-separated words in text that match pattern and replaces
    them with replacement. Here pattern may contain a ‘%’ which acts as a
    wildcard, matching any number of any characters within a word. If
    replacement also contains a ‘%’, the ‘%’ is replaced by the text that
    matched the ‘%’ in pattern. Only the first ‘%’ in the pattern and
    replacement is treated this way; any subsequent ‘%’ is unchanged.

    ‘%’ characters in |patsubst| function invocations can be quoted with
    preceding backslashes (‘\’). Backslashes that would otherwise quote ‘%’
    characters can be quoted with more backslashes. Backslashes that quote ‘%’
    characters or other backslashes are removed from the pattern before it is
    compared file names or has a stem substituted into it. Backslashes that are
    not in danger of quoting ‘%’ characters go unmolested. For example, the
    pattern the\%weird\\%pattern\\ has ‘the%weird\’ preceding the operative ‘%’
    character, and ‘pattern\\’ following it. The final two backslashes are left
    alone because they cannot affect any ‘%’ character.

    Whitespace between words is folded into single space characters; leading
    and trailing whitespace is discarded.

    For example,

    $(|patsubst| %.c,%.o,x.c.c bar.c)

    produces the value ‘x.c.o bar.o’.

    Substitution references (see Substitution References) are a simpler way to
    get the effect of the |patsubst| function:

    $(var:pattern=replacement)

    is equivalent to

    $(|patsubst| pattern,replacement,$(var))

    The second shorthand simplifies one of the most common uses of |patsubst|:
    replacing the suffix at the end of file names.

    $(var:suffix=replacement)

    is equivalent to

    $(|patsubst| %suffix,%replacement,$(var))

    For example, you might have a list of object files:

    objects = foo.o bar.o baz.o

    To get the list of corresponding source files, you could simply write:

    $(objects:.o=.c)

    instead of using the general form:

    $(|patsubst| %.o,%.c,$(objects))

$(*strip* string)

    Removes leading and trailing whitespace from string and replaces each
    internal sequence of one or more whitespace characters with a single space.
    Thus, ‘$(|strip| a b c )’ results in ‘a b c’.

    The function |strip| can be very useful when used in conjunction with
    conditionals. When comparing something with the empty string ‘’ using ifeq
    or ifneq, you usually want a string of just whitespace to match the empty
    string (see Conditionals).

    Thus, the following may fail to have the desired results:

    .|PHONY|: all
    ifneq   "$(needs_made)" ""
    all: $(needs_made)
    else
    all:;@echo 'Nothing to make!'
    endif

    Replacing the variable reference ‘$(needs_made)’ with the function call
    ‘$(|strip| $(needs_made))’ in the ifneq directive would make it more robust.

$(*findstring* find,in)

    Searches in for an occurrence of find. If it occurs, the value is find;
    otherwise, the value is empty. You can use this function in a conditional
    to test for the presence of a specific substring in a given string. Thus,
    the two examples,

    $(|findstring| a,a b c)
    $(|findstring| a,b c)

    produce the values ‘a’ and ‘’ (the empty string), respectively. See Testing
    Flags, for a practical application of |findstring|.

$(*filter* pattern…,text)

    Returns all whitespace-separated words in text that do match any of the
    pattern words, removing any words that do not match. The patterns are
    written using ‘%’, just like the patterns used in the |patsubst| function
    above.

    The |filter| function can be used to separate out different types of strings
    (such as file names) in a variable. For example:

    sources := foo.c bar.c baz.s ugh.h
    foo: $(sources)
            cc $(|filter| %.c %.s,$(sources)) -o foo

    says that foo depends of foo.c, bar.c, baz.s and ugh.h but only foo.c,
    bar.c and baz.s should be specified in the command to the compiler.

$(*filter-out* pattern…,text)

    Returns all whitespace-separated words in text that do not match any of the
    pattern words, removing the words that do match one or more. This is the
    exact opposite of the |filter| function.

    For example, given:

    objects=main1.o foo.o main2.o bar.o
    mains=main1.o main2.o

    the following generates a list which contains all the object files not in
    ‘mains’:

    $(|filter-out| $(mains),$(objects))

$(*sort* list)

    Sorts the words of list in lexical order, removing duplicate words. The
    output is a list of words separated by single spaces. Thus,

    $(|sort| foo bar lose)

    returns the value ‘bar foo lose’.

    Incidentally, since |sort| removes duplicate words, you can use it for this
    purpose even if you don’t care about the |sort| order.

$(*word* n,text)

    Returns the nth |word| of text. The legitimate values of n start from 1. If n
    is bigger than the number of words in text, the value is empty. For
    example,

    $(|word| 2, foo bar baz)

    returns ‘bar’.

$(*wordlist* s,e,text)

    Returns the list of words in text starting with word s and ending with word
    e (inclusive). The legitimate values of s start from 1; e may start from 0.
    If s is bigger than the number of words in text, the value is empty. If e
    is bigger than the number of words in text, words up to the end of text are
    returned. If s is greater than e, nothing is returned. For example,

    $(wordlist 2, 3, foo bar baz)

    returns ‘bar baz’.

$(*words* text)

    Returns the number of words in text. Thus, the last word of text is $(|word|
    $(words text),text).

$(*firstword* names…)

    The argument names is regarded as a series of names, separated by
    whitespace. The value is the first name in the series. The rest of the
    names are ignored.

    For example,

    $(|firstword| foo bar)

    produces the result ‘foo’. Although $(|firstword| text) is the same as $(|word|
    1,text), the |firstword| function is retained for its simplicity.

$(*lastword* names…)

    The argument names is regarded as a series of names, separated by
    whitespace. The value is the last name in the series.

    For example,

    $(|lastword| foo bar)

    produces the result ‘bar’. Although $(|lastword| text) is the same as $(|word|
    $(words text),text), the |lastword| function was added for its simplicity and
    better performance. 

Here is a realistic example of the use of |subst| and |patsubst|. Suppose that a
makefile uses the VPATH variable to specify a list of directories that make
should search for prerequisite files (see VPATH Search Path for All
Prerequisites). This example shows how to tell the C compiler to search for
header files in the same list of directories.

The value of VPATH is a list of directories separated by colons, such as
‘src:../headers’. First, the |subst| function is used to change the colons to
spaces:

$(|subst| :, ,$(VPATH))

This produces ‘src ../headers’. Then |patsubst| is used to turn each directory
name into a ‘-I’ flag. These can be added to the value of the variable CFLAGS,
which is passed automatically to the C compiler, like this:

override CFLAGS += $(|patsubst| %,-I%,$(|subst| :, ,$(VPATH)))

The effect is to append the text ‘-Isrc -I../headers’ to the previously given
value of CFLAGS. The override directive is used so that the new value is
assigned even if the previous value of CFLAGS was specified with a command
argument (see The override Directive). 

==============================================================================

8.3 Functions for File Names

Several of the built-in expansion functions relate specifically to taking apart
file names or lists of file names.

Each of the following functions performs a specific transformation on a file
name. The argument of the function is regarded as a series of file names,
separated by whitespace. (Leading and trailing whitespace is ignored.) Each
file name in the series is transformed in the same way and the results are
concatenated with single spaces between them.

$(*dir* names…)

    Extracts the directory-part of each file name in names. The directory-part
    of the file name is everything up through (and including) the last slash in
    it. If the file name contains no slash, the directory part is the string
    ‘./’. For example,

    $(|dir| src/foo.c hacks)

    produces the result ‘src/ ./’.

$(*notdir* names…)

    Extracts all but the directory-part of each file name in names. If the file
    name contains no slash, it is left unchanged. Otherwise, everything through
    the last slash is removed from it.

    A file name that ends with a slash becomes an empty string. This is
    unfortunate, because it means that the result does not always have the same
    number of whitespace-separated file names as the argument had; but we do
    not see any other valid alternative.

    For example,

    $(|notdir| src/foo.c hacks)

    produces the result ‘foo.c hacks’.

$(*suffix* names…)

    Extracts the suffix of each file name in names. If the file name contains a
    period, the suffix is everything starting with the last period. Otherwise,
    the suffix is the empty string. This frequently means that the result will
    be empty when names is not, and if names contains multiple file names, the
    result may contain fewer file names.

    For example,

    $(|suffix| src/foo.c src-1.0/bar.c hacks)

    produces the result ‘.c .c’.

$(*basename* names…)

    Extracts all but the suffix of each file name in names. If the file name
    contains a period, the basename is everything starting up to (and not
    including) the last period. Periods in the directory part are ignored. If
    there is no period, the basename is the entire file name. For example,

    $(|basename| src/foo.c src-1.0/bar hacks)

    produces the result ‘src/foo src-1.0/bar hacks’.

$(*addsuffix* suffix,names…)

    The argument names is regarded as a series of names, separated by
    whitespace; suffix is used as a unit. The value of suffix is appended to
    the end of each individual name and the resulting larger names are
    concatenated with single spaces between them. For example,

    $(|addsuffix| .c,foo bar)

    produces the result ‘foo.c bar.c’.

$(*addprefix* prefix,names…)

    The argument names is regarded as a series of names, separated by
    whitespace; prefix is used as a unit. The value of prefix is prepended to
    the front of each individual name and the resulting larger names are
    concatenated with single spaces between them. For example,

    $(|addprefix| src/,foo bar)

    produces the result ‘src/foo src/bar’.

$(*join* list1,list2)

    Concatenates the two arguments word by word: the two first words (one from
    each argument) concatenated form the first word of the result, the two
    second words form the second word of the result, and so on. So the nth word
    of the result comes from the nth word of each argument. If one argument has
    more words that the other, the extra words are copied unchanged into the
    result.

    For example, ‘$(|join| a b,.c .o)’ produces ‘a.c b.o’.

    Whitespace between the words in the lists is not preserved; it is replaced
    with a single space.

    This function can merge the results of the |dir| and |notdir| functions, to
    produce the original list of files which was given to those two functions.

$(*wildcard* pattern)

    The argument pattern is a file name pattern, typically containing wildcard
    characters (as in shell file name patterns). The result of wildcard is a
    space-separated list of the names of existing files that match the pattern.
    See Using Wildcard Characters in File Names.

$(*realpath* names…)

    For each file name in names return the canonical absolute name. A canonical
    name does not contain any . or .. components, nor any repeated path
    separators (/) or symlinks. In case of a failure the empty string is
    returned. Consult the realpath(3) documentation for a list of possible
    failure causes.

$(*abspath* names…)

    For each file name in names return an absolute name that does not contain
    any . or .. components, nor any repeated path separators (/). Note that, in
    contrast to realpath function, abspath does not resolve symlinks and does
    not require the file names to refer to an existing file or directory. Use
    the wildcard function to test for existence. 

==============================================================================

8.4 Functions for Conditionals

There are three functions that provide conditional expansion. A key aspect of
these functions is that not all of the arguments are expanded initially. Only
those arguments which need to be expanded, will be expanded.

$(*if* condition,then-part[,else-part])

    The if function provides support for conditional expansion in a functional
    context (as opposed to the GNU make makefile conditionals such as ifeq (see
    Syntax of Conditionals).

    The first argument, condition, first has all preceding and trailing
    whitespace stripped, then is expanded. If it expands to any non-empty
    string, then the condition is considered to be true. If it expands to an
    empty string, the condition is considered to be false.

    If the condition is true then the second argument, then-part, is evaluated
    and this is used as the result of the evaluation of the entire if function.

    If the condition is false then the third argument, else-part, is evaluated
    and this is the result of the if function. If there is no third argument,
    the if function evaluates to nothing (the empty string).

    Note that only one of the then-part or the else-part will be evaluated,
    never both. Thus, either can contain side-effects (such as shell function
    calls, etc.)

$(*or* condition1[,condition2[,condition3…]])

    The or function provides a “short-circuiting” OR operation. Each argument
    is expanded, in order. If an argument expands to a non-empty string the
    processing stops and the result of the expansion is that string. If, after
    all arguments are expanded, all of them are false (empty), then the result
    of the expansion is the empty string.

$(*and* condition1[,condition2[,condition3…]])

    The and function provides a “short-circuiting” AND operation. Each argument
    is expanded, in order. If an argument expands to an empty string the
    processing stops and the result of the expansion is the empty string. If
    all arguments expand to a non-empty string then the result of the expansion
    is the expansion of the last argument.

==============================================================================

8.5 The *foreach* Function

The foreach function is very different from other functions. It causes one
piece of text to be used repeatedly, each time with a different substitution
performed on it. It resembles the for command in the shell sh and the foreach
command in the C-shell csh.

The syntax of the foreach function is:

$(foreach var,list,text)

The first two arguments, var and list, are expanded before anything else is
done; note that the last argument, text, is not expanded at the same time. Then
for each word of the expanded value of list, the variable named by the expanded
value of var is set to that word, and text is expanded. Presumably text
contains references to that variable, so its expansion will be different each
time.

The result is that text is expanded as many times as there are
whitespace-separated words in list. The multiple expansions of text are
concatenated, with spaces between them, to make the result of foreach.

This simple example sets the variable ‘files’ to the list of all files in the
directories in the list ‘dirs’:

dirs := a b c d
files := $(foreach dir,$(dirs),$(|wildcard| $(dir)/*))

Here text is ‘$(|wildcard| $(dir)/*)’. The first repetition finds the value ‘a’
for dir, so it produces the same result as ‘$(|wildcard| a/*)’; the second
repetition produces the result of ‘$(|wildcard| b/*)’; and the third, that of
‘$(|wildcard| c/*)’.

This example has the same result (except for setting ‘dirs’) as the following
example:

files := $(|wildcard| a/* b/* c/* d/*)

When text is complicated, you can improve readability by giving it a name, with
an additional variable:

find_files = $(|wildcard| $(dir)/*)
dirs := a b c d
files := $(foreach dir,$(dirs),$(find_files))

Here we use the variable find_files this way. We use plain ‘=’ to define a
recursively-expanding variable, so that its value contains an actual function
call to be re-expanded under the control of foreach; a simply-expanded variable
would not do, since wildcard would be called only once at the time of defining
find_files.

The foreach function has no permanent effect on the variable var; its value and
flavor after the foreach function call are the same as they were beforehand.
The other values which are taken from list are in effect only temporarily,
during the execution of foreach. The variable var is a simply-expanded variable
during the execution of foreach. If var was undefined before the foreach
function call, it is undefined after the call. See The Two Flavors of
Variables.

You must take care when using complex variable expressions that result in
variable names because many strange things are valid variable names, but are
probably not what you intended. For example,

files := $(foreach Esta-escrito-en-espanol!,b c ch,$(find_files))

might be useful if the value of find_files references the variable whose name
is ‘Esta-escrito-en-espanol!’ (es un nombre bastante largo, no?), but it is
more likely to be a mistake. 

==============================================================================

8.6 The *file* Function

The file function allows the makefile to write to a file. Two modes of writing
are supported: overwrite, where the text is written to the beginning of the
file and any existing content is lost, and append, where the text is written to
the end of the file, preserving the existing content. In all cases the file is
created if it does not exist.

The syntax of the file function is:

$(file op filename[,text])

The operator op can be either > which indicates overwrite mode, or >> which
indicates append mode. The filename indicates the file to be written to. There
may optionally be whitespace between the operator and the file name.

When the file function is expanded all its arguments are expanded first, then
the file indicated by filename will be opened in the mode described by op.
Finally text will be written to the file. If text does not already end in a
newline, even if empty, a final newline will be written. If the text argument
is not given, nothing will be written. The result of evaluating the file
function is always the empty string.

It is a fatal error if the file cannot be opened for writing, or if the write
operation fails.

For example, the file function can be useful if your build system has a limited
command line size and your recipe runs a command that can accept arguments from
a file as well. Many commands use the convention that an argument prefixed with
an @ specifies a file containing more arguments. Then you might write your
recipe in this way:

program: $(OBJECTS)
        $(|file| >$@.in,$^)
        $(CMD) $(CMDFLAGS) @$@.in
        @rm $@.in

If the command required each argument to be on a separate line of the input
file, you might write your recipe like this:

program: $(OBJECTS)
        $(file >$@.in) $(foreach O,$^,$(file >>$@.in,$O))
        $(CMD) $(CMDFLAGS) @$@.in
        @rm $@.in

==============================================================================

8.7 The *call* Function

The call function is unique in that it can be used to create new parameterized
functions. You can write a complex expression as the value of a variable, then
use call to expand it with different values.

The syntax of the call function is:

$(|call| variable,param,param,…)

When make expands this function, it assigns each param to temporary variables
$(1), $(2), etc. The variable $(0) will contain variable. There is no maximum
number of parameter arguments. There is no minimum, either, but it doesn’t make
sense to use call with no parameters.

Then variable is expanded as a make variable in the context of these temporary
assignments. Thus, any reference to $(1) in the value of variable will resolve
to the first param in the invocation of call.

Note that variable is the name of a variable, not a reference to that variable.
Therefore you would not normally use a ‘$’ or parentheses when writing it. (You
can, however, use a variable reference in the name if you want the name not to
be a constant.)

If variable is the name of a built-in function, the built-in function is always
invoked (even if a make variable by that name also exists).

The call function expands the param arguments before assigning them to
temporary variables. This means that variable values containing references to
built-in functions that have special expansion rules, like foreach or if, may
not work as you expect.

Some examples may make this clearer.

This macro simply reverses its arguments:

reverse = $(2) $(1)

foo = $(|call| reverse,a,b)

Here foo will contain ‘b a’.

This one is slightly more interesting: it defines a macro to search for the
first instance of a program in PATH:

pathsearch = $(|firstword| $(|wildcard| $(|addsuffix| /$(1),$(|subst| :, ,$(PATH)))))

LS := $(|call| pathsearch,ls)

Now the variable LS contains /bin/ls or similar.

The call function can be nested. Each recursive invocation gets its own local
values for $(1), etc. that mask the values of higher-level call. For example,
here is an implementation of a map function:

map = $(|foreach| a,$(2),$(|call| $(1),$(a)))

Now you can map a function that normally takes only one argument, such as
origin, to multiple values in one step:

o = $(|call| map,origin,o map MAKE)

and end up with o containing something like ‘file file default’.

A final caution: be careful when adding whitespace to the arguments to call. As
with other functions, any whitespace contained in the second and subsequent
arguments is kept; this can cause strange effects. It’s generally safest to
remove all extraneous whitespace when providing parameters to call. 

==============================================================================

8.8 The *value* Function

The value function provides a way for you to use the value of a variable
without having it expanded. Please note that this does not undo expansions
which have already occurred; for example if you create a simply expanded
variable its value is expanded during the definition; in that case the value
function will return the same result as using the variable directly.

The syntax of the value function is:

$(|value| variable)

Note that variable is the name of a variable, not a reference to that variable.
Therefore you would not normally use a ‘$’ or parentheses when writing it. (You
can, however, use a variable reference in the name if you want the name not to
be a constant.)

The result of this function is a string containing the value of variable,
without any expansion occurring. For example, in this makefile:

FOO = $PATH

all:
        @echo $(FOO)
        @echo $(|value| FOO)

The first output line would be ATH, since the “$P” would be expanded as a make
variable, while the second output line would be the current value of your $PATH
environment variable, since the value function avoided the expansion.

The value function is most often used in conjunction with the eval function
(see Eval Function). 

==============================================================================

8.9 The eval Function

The eval function is very special: it allows you to define new makefile
constructs that are not constant; which are the result of evaluating other
variables and functions. The argument to the eval function is expanded, then
the results of that expansion are parsed as makefile syntax. The expanded
results can define new make variables, targets, implicit or explicit rules,
etc.

The result of the eval function is always the empty string; thus, it can be
placed virtually anywhere in a makefile without causing syntax errors.

It’s important to realize that the eval argument is expanded twice; first by
the eval function, then the results of that expansion are expanded again when
they are parsed as makefile syntax. This means you may need to provide extra
levels of escaping for “$” characters when using eval. The value function (see
Value Function) can sometimes be useful in these situations, to circumvent
unwanted expansions.

Here is an example of how eval can be used; this example combines a number of
concepts and other functions. Although it might seem overly complex to use eval
in this example, rather than just writing out the rules, consider two things:
first, the template definition (in PROGRAM_template) could need to be much more
complex than it is here; and second, you might put the complex, “generic” part
of this example into another makefile, then include it in all the individual
makefiles. Now your individual makefiles are quite straightforward.

PROGRAMS    = server client

server_OBJS = server.o server_priv.o server_access.o
server_LIBS = priv protocol

client_OBJS = client.o client_api.o client_mem.o
client_LIBS = protocol

# Everything after this is generic


.|PHONY|: all
all: $(PROGRAMS)

define PROGRAM_template =
 $(1): $$($(1)_OBJS) $$($(1)_LIBS:%=-l%)
 ALL_OBJS   += $$($(1)_OBJS)
endef
 $(foreach prog,$(PROGRAMS),$(eval $(|call| PROGRAM_template,$(prog))))
 $(PROGRAMS):
        $(LINK.o) $^ $(LDLIBS) -o $@

clean:
        rm -f $(ALL_OBJS) $(PROGRAMS)

==============================================================================

8.10 The *origin* Function

The origin function is unlike most other functions in that it does not operate
on the values of variables; it tells you something about a variable.
Specifically, it tells you where it came from.

The syntax of the origin function is:

$(|origin| variable)

Note that variable is the name of a variable to inquire about, not a reference
to that variable. Therefore you would not normally use a ‘$’ or parentheses
when writing it. (You can, however, use a variable reference in the name if you
want the name not to be a constant.)

The result of this function is a string telling you how the variable variable
was defined:

‘undefined’

    if variable was never defined.

‘default’

    if variable has a default definition, as is usual with CC and so on. See
    Variables Used by Implicit Rules. Note that if you have redefined a default
    variable, the origin function will return the origin of the later
    definition.

‘environment’

    if variable was inherited from the environment provided to make.

‘environment override’

    if variable was inherited from the environment provided to make, and is
    overriding a setting for variable in the makefile as a result of the ‘-e’
    option (see Summary of Options).

‘file’

    if variable was defined in a makefile.

‘command line’

    if variable was defined on the command line.

‘override’

    if variable was defined with an override directive in a makefile (see The
    override Directive).

‘automatic’

    if variable is an automatic variable defined for the execution of the
    recipe for each rule (see Automatic Variables). 

This information is primarily useful (other than for your curiosity) to
determine if you want to believe the value of a variable. For example, suppose
you have a makefile foo that includes another makefile bar. You want a variable
bletch to be defined in bar if you run the command ‘make -f bar’, even if the
environment contains a definition of bletch. However, if foo defined bletch
before including bar, you do not want to override that definition. This could
be done by using an override directive in foo, giving that definition
precedence over the later definition in bar; unfortunately, the override
directive would also override any command line definitions. So, bar could
include:

ifdef bletch
ifeq "$|(origin| bletch)" "environment"
bletch = barf, gag, etc.
endif
endif

If bletch has been defined from the environment, this will redefine it.

If you want to override a previous definition of bletch if it came from the
environment, even under ‘-e’, you could instead write:

ifneq "$(|findstring| environment,$(|origin| bletch))" ""
bletch = barf, gag, etc.
endif

Here the redefinition takes place if ‘$(|origin| bletch)’ returns either
‘environment’ or ‘environment override’. See Functions for String Substitution
and Analysis. 

==============================================================================

8.11 The *flavor* Function

The flavor function, like the origin function, does not operate on the values
of variables but rather it tells you something about a variable. Specifically,
it tells you the flavor of a variable (see The Two Flavors of Variables).

The syntax of the flavor function is:

$(|flavor| variable)

Note that variable is the name of a variable to inquire about, not a reference
to that variable. Therefore you would not normally use a ‘$’ or parentheses
when writing it. (You can, however, use a variable reference in the name if you
want the name not to be a constant.)

The result of this function is a string that identifies the flavor of the
variable variable:

‘undefined’

    if variable was never defined.

‘recursive’

    if variable is a recursively expanded variable.

‘simple’

    if variable is a simply expanded variable.

==============================================================================

8.12 Functions That Control Make

These functions control the way make runs. Generally, they are used to provide
information to the user of the makefile or to cause make to stop if some sort
of environmental error is detected.

$(*error* text…)

    Generates a fatal error where the message is text. Note that the error is
    generated whenever this function is evaluated. So, if you put it inside a
    recipe or on the right side of a recursive variable assignment, it won’t be
    evaluated until later. The text will be expanded before the error is
    generated.

    For example,

    ifdef ERROR1
    $(|error| error is $(ERROR1))
    endif

    will generate a fatal error during the read of the makefile if the make
    variable ERROR1 is defined. Or,

    ERR = $(|error| found an error!)

    .|PHONY|: err
    err: ; $(ERR)

    will generate a fatal error while make is running, if the err target is
    invoked.

$(*warning* text…)

    This function works similarly to the error function, above, except that
    make doesn’t exit. Instead, text is expanded and the resulting message is
    displayed, but processing of the makefile continues.

    The result of the expansion of this function is the empty string.

$(*info* text…)

    This function does nothing more than print its (expanded) argument(s) to
    standard output. No makefile name or line number is added. The result of
    the expansion of this function is the empty string. 

==============================================================================

8.13 The *shell* Function

The shell function is unlike any other function other than the wildcard
function (see The Function wildcard) in that it communicates with the world
outside of make.

The shell function performs the same function that backquotes (‘`’) perform in
most shells: it does command expansion. This means that it takes as an argument
a shell command and evaluates to the output of the command. The only processing
make does on the result is to convert each newline (or carriage-return /
newline pair) to a single space. If there is a trailing (carriage-return and)
newline it will simply be removed.

The commands run by calls to the shell function are run when the function calls
are expanded (see How make Reads a Makefile). Because this function involves
spawning a new shell, you should carefully consider the performance
implications of using the shell function within recursively expanded variables
vs. simply expanded variables (see The Two Flavors of Variables).

Here are some examples of the use of the shell function:

contents := $(|shell| cat foo)

sets contents to the contents of the file foo, with a space (rather than a
newline) separating each line.

files := $(|shell| echo *.c)

sets files to the expansion of ‘*.c’. Unless make is using a very strange
shell, this has the same result as ‘$(|wildcard| *.c)’ (as long as at least one
‘.c’ file exists). 

==============================================================================

8.14 The guile Function

If GNU make is built with support for GNU Guile as an embedded extension
language then the guile function will be available. The guile function takes
one argument which is first expanded by make in the normal fashion, then passed
to the GNU Guile evaluator. The result of the evaluator is converted into a
string and used as the expansion of the guile function in the makefile. See GNU
Guile Integration for details on writing extensions to make in Guile.

You can determine whether GNU Guile support is available by checking the

.FEATURES variable for the word guile. 

==============================================================================

10.5.3 Automatic Variables

Suppose you are writing a pattern rule to compile a ‘.c’ file into a ‘.o’ file:
how do you write the ‘cc’ command so that it operates on the right source file
name? You cannot write the name in the recipe, because the name is different
each time the implicit rule is applied.

What you do is use a special feature of make, the automatic variables. These
variables have values computed afresh for each rule that is executed, based on
the target and prerequisites of the rule. In this example, you would use ‘$@’
for the object file name and '|$<|' for the source file name.

It’s very important that you recognize the limited scope in which automatic
variable values are available: they only have values within the recipe. In
particular, you cannot use them anywhere within the target list of a rule; they
have no value there and will expand to the empty string. Also, they cannot be
accessed directly within the prerequisite list of a rule. A common mistake is
attempting to use $@ within the prerequisites list; this will not work.
However, there is a special feature of GNU make, secondary expansion (see
Secondary Expansion), which will allow automatic variable values to be used in
prerequisite lists.

Here is a table of automatic variables:

*$@*

    The file name of the target of the rule. If the target is an archive
    member, then ‘$@’ is the name of the archive file. In a pattern rule that
    has multiple targets (see Introduction to Pattern Rules), ‘$@’ is the name
    of whichever target caused the rule’s recipe to be run.

*$%*

    The target member name, when the target is an archive member. See Archives.
    For example, if the target is foo.a(bar.o) then ‘$%’ is bar.o and ‘$@’ is
    foo.a. ‘$%’ is empty when the target is not an archive member.

*$<*

    The name of the first prerequisite. If the target got its recipe from an
    implicit rule, this will be the first prerequisite added by the implicit
    rule (see Implicit Rules).

*$?*

    The names of all the prerequisites that are newer than the target, with
    spaces between them. For prerequisites which are archive members, only the
    named member is used (see Archives).

*$^*

    The names of all the prerequisites, with spaces between them. For
    prerequisites which are archive members, only the named member is used (see
    Archives). A target has only one prerequisite on each other file it depends
    on, no matter how many times each file is listed as a prerequisite. So if
    you list a prerequisite more than once for a target, the value of $^
    contains just one copy of the name. This list does not contain any of the
    order-only prerequisites; for those see the ‘$|’ variable, below.

*$+*

    This is like ‘$^’, but prerequisites listed more than once are duplicated
    in the order they were listed in the makefile. This is primarily useful for
    use in linking commands where it is meaningful to repeat library file names
    in a particular order.

*$|*

    The names of all the order-only prerequisites, with spaces between them.

$*

    The stem with which an implicit rule matches (see How Patterns Match). If
    the target is dir/a.foo.b and the target pattern is a.%.b then the stem is
    dir/foo. The stem is useful for constructing names of related files.

    In a static pattern rule, the stem is part of the file name that matched
    the ‘%’ in the target pattern.

    In an explicit rule, there is no stem; so ‘$*’ cannot be determined in that
    way. Instead, if the target name ends with a recognized suffix (see
    Old-Fashioned Suffix Rules), ‘$*’ is set to the target name minus the
    suffix. For example, if the target name is ‘foo.c’, then ‘$*’ is set to
    ‘foo’, since ‘.c’ is a suffix. GNU make does this bizarre thing only for
    compatibility with other implementations of make. You should generally
    avoid using ‘$*’ except in implicit rules or static pattern rules.

    If the target name in an explicit rule does not end with a recognized
    suffix, ‘$*’ is set to the empty string for that rule. 

'|$?|' is useful even in explicit rules when you wish to operate on only the
prerequisites that have changed. For example, suppose that an archive named lib
is supposed to contain copies of several object files. This rule copies just
the changed object files into the archive:

lib: foo.o bar.o lose.o win.o
        ar r lib $?

Of the variables listed above, four have values that are single file names, and
three have values that are lists of file names. These seven have variants that
get just the file’s directory name or just the file name within the directory.
The variant variables’ names are formed by appending ‘D’ or ‘F’, respectively.
These variants are semi-obsolete in GNU make since the functions |dir| and |notdir|
can be used to get a similar effect (see Functions for File Names). Note,
however, that the ‘D’ variants all omit the trailing slash which always appears
in the output of the dir function. Here is a table of the variants:

‘$(@D)’

    The directory part of the file name of the target, with the trailing slash
    removed. If the value of ‘$@’ is dir/foo.o then ‘$(@D)’ is dir. This value
    is . if ‘$@’ does not contain a slash.

‘$(@F)’

    The file-within-directory part of the file name of the target. If the value
    of ‘$@’ is dir/foo.o then ‘$(@F)’ is foo.o. ‘$(@F)’ is equivalent to
    ‘$(|notdir| $@)’.

‘$(*D)’
‘$(*F)’

    The directory part and the file-within-directory part of the stem; dir and
    foo in this example.

‘$(%D)’
‘$(%F)’

    The directory part and the file-within-directory part of the target archive
    member name. This makes sense only for archive member targets of the form
    archive(member) and is useful only when member may contain a directory
    name. (See Archive Members as Targets.)

‘$(<D)’
‘$(<F)’

    The directory part and the file-within-directory part of the first
    prerequisite.

‘$(^D)’
‘$(^F)’

    Lists of the directory parts and the file-within-directory parts of all
    prerequisites.

‘$(+D)’
‘$(+F)’

    Lists of the directory parts and the file-within-directory parts of all
    prerequisites, including multiple instances of duplicated prerequisites.

‘$(?D)’
‘$(?F)’

    Lists of the directory parts and the file-within-directory parts of all
    prerequisites that are newer than the target. 

Note that we use a special stylistic convention when we talk about these
automatic variables; we write “the value of ‘$<’”, rather than “the variable <”
as we would write for ordinary variables such as objects and CFLAGS. We think
this convention looks more natural in this special case. Please do not assume
it has a deep significance; ‘$<’ refers to the variable named < just as
‘$(CFLAGS)’ refers to the variable named CFLAGS. You could just as well use
‘$(<)’ in place of ‘$<’. 

==============================================================================

6.14 Other Special Variables

GNU make supports some variables that have special properties.

*MAKEFILE_LIST*

    Contains the name of each makefile that is parsed by make, in the order in
    which it was parsed. The name is appended just before make begins to parse
    the makefile. Thus, if the first thing a makefile does is examine the last
    word in this variable, it will be the name of the current makefile. Once
    the current makefile has used include, however, the last word will be the
    just-included makefile.

    If a makefile named Makefile has this content:

    name1 := $(|lastword| $(|MAKEFILE_LIST|))

    include inc.mk

    name2 := $(|lastword| $(|MAKEFILE_LIST|))

    all:
            @echo name1 = $(name1)
            @echo name2 = $(name2)

    then you would expect to see this output:

    name1 = Makefile
    name2 = inc.mk

.*DEFAULT_GOAL*

    Sets the default goal to be used if no targets were specified on the
    command line (see Arguments to Specify the Goals). The .|DEFAULT_GOAL|
    variable allows you to discover the current default goal, restart the
    default goal selection algorithm by clearing its value, or to explicitly
    set the default goal. The following example illustrates these cases:

    # Query the default goal.
    ifeq ($(.|DEFAULT_GOAL|),)
      $(warning no default goal is set)
    endif

    .|PHONY|: foo
    foo: ; @echo $@

    $(warning default goal is $(.|DEFAULT_GOAL|))

    # Reset the default goal.
    .|DEFAULT_GOAL| :=

    .|PHONY|: bar
    bar: ; @echo $@

    $(warning default goal is $(.|DEFAULT_GOAL|))

    # Set our own.
    .|DEFAULT_GOAL| := foo

    This makefile prints:

    no default goal is set
    default goal is foo
    default goal is bar
    foo

    Note that assigning more than one target name to .|DEFAULT_GOAL| is invalid
    and will result in an error.

*MAKE_RESTARTS*

    This variable is set only if this instance of make has restarted (see How
    Makefiles Are Remade): it will contain the number of times this instance
    has restarted. Note this is not the same as recursion (counted by the
    MAKELEVEL variable). You should not set, modify, or export this variable.

*MAKE_TERMOUT*
*MAKE_TERMERR*

    When make starts it will check whether stdout and stderr will show their
    output on a terminal. If so, it will set MAKE_TERMOUT and MAKE_TERMERR,
    respectively, to the name of the terminal device (or true if this cannot be
    determined). If set these variables will be marked for export. These
    variables will not be changed by make and they will not be modified if
    already set.

    These values can be used (particularly in combination with output
    synchronization (see Output During Parallel Execution) to determine whether
    make itself is writing to a terminal; they can be tested to decide whether
    to force recipe commands to generate colorized output for example.

    If you invoke a sub-make and redirect its stdout or stderr it is your
    responsibility to reset or unexport these variables as well, if your
    makefiles rely on them.

.*RECIPEPREFIX*

    The first character of the value of this variable is used as the character
    make assumes is introducing a recipe line. If the variable is empty (as it
    is by default) that character is the standard tab character. For example,
    this is a valid makefile:

    .RECIPEPREFIX = >
    all:
    > @echo Hello, world

    The value of .RECIPEPREFIX can be changed multiple times; once set it stays
    in effect for all rules parsed until it is modified.

.*VARIABLES*

    Expands to a list of the names of all global variables defined so far. This
    includes variables which have empty values, as well as built-in variables
    (see Variables Used by Implicit Rules), but does not include any variables
    which are only defined in a target-specific context. Note that any value
    you assign to this variable will be ignored; it will always return its
    special value.

.*FEATURES*

    Expands to a list of special features supported by this version of make.
    Possible values include, but are not limited to:

    ‘archives’

        Supports ar (archive) files using special file name syntax. See Using
        make to Update Archive Files.

    ‘check-symlink’

        Supports the -L (--check-symlink-times) flag. See Summary of Options.

    ‘else-if’

        Supports “else if” non-nested conditionals. See Syntax of Conditionals.

    ‘jobserver’

        Supports “job server” enhanced parallel builds. See Parallel Execution.

    ‘oneshell’

        Supports the .|ONESHELL| special target. See Using One Shell.

    ‘order-only’

        Supports order-only prerequisites. See Types of Prerequisites.

    ‘second-expansion’

        Supports secondary expansion of prerequisite lists.

    ‘shortest-stem’

        Uses the “shortest stem” method of choosing which pattern, of multiple
        applicable options, will be used. See How Patterns Match.

    ‘target-specific’

        Supports target-specific and pattern-specific variable assignments. See
        Target-specific Variable Values.

    ‘undefine’

        Supports the undefine directive. See Undefine Directive.

    ‘guile’

        Has GNU Guile available as an embedded extension language. See GNU
        Guile Integration.

    ‘load’

        Supports dynamically loadable objects for creating custom extensions.
        See Loading Dynamic Objects. 


.*INCLUDE_DIRS*

    Expands to a list of directories that make searches for included makefiles
    (see Including Other Makefiles).

==============================================================================

12.2.1 The *load* Directive

Objects are loaded into GNU make by placing the load directive into your
makefile. The syntax of the load directive is as follows:

|load| object-file …

or:

|load| object-file(symbol-name) …

The file object-file is dynamically loaded by GNU make. If object-file does not
include a directory path then it is first looked for in the current directory.
If it is not found there, or a directory path is included, then system-specific
paths will be searched. If the load fails for any reason, make will print a
message and exit.

If the load succeeds make will invoke an initializing function.

If symbol-name is provided, it will be used as the name of the initializing
function.

If no symbol-name is provided, the initializing function name is created by
taking the base file name of object-file, up to the first character which is
not a valid symbol name character (alphanumerics and underscores are valid
symbol name characters). To this prefix will be appended the suffix _gmk_setup.

More than one object file may be loaded with a single load directive, and both
forms of load arguments may be used in the same directive.

The initializing function will be provided the file name and line number of the
invocation of the load operation. It should return a value of type int, which
must be 0 on failure and non-0 on success. If the return value is -1, then GNU
make will not attempt to rebuild the object file (see How Loaded Objects Are
Remade).

For example:

|load| ../mk_funcs.so

will load the dynamic object ../mk_funcs.so. After the object is loaded, make
will invoke the function (assumed to be defined by the shared object)
mk_funcs_gmk_setup.

On the other hand:

|load| ../mk_funcs.so(init_mk_func)

will load the dynamic object ../mk_funcs.so. After the object is loaded, make
will invoke the function init_mk_func.

Regardless of how many times an object file appears in a load directive, it
will only be loaded (and its setup function will only be invoked) once.

After an object has been successfully loaded, its file name is appended to the

.|LOADED| variable.

If you would prefer that failure to load a dynamic object not be reported as an
error, you can use the -load directive instead of load. GNU make will not fail
and no message will be generated if an object fails to load. The failed object
is not added to the .LOADED variable, which can then be consulted to determine
if the load was successful. 

==============================================================================

4.9 Special Built-in Target Names

Certain names have special meanings if they appear as targets.

.*PHONY*

    The prerequisites of the special target .|PHONY| are considered to be phony
    targets. When it is time to consider such a target, make will run its
    recipe unconditionally, regardless of whether a file with that name exists
    or what its last-modification time is. See Phony Targets.

.*SUFFIXES*

    The prerequisites of the special target .|SUFFIXES| are the list of suffixes
    to be used in checking for suffix rules. See Old-Fashioned Suffix Rules.

.*DEFAULT*

    The recipe specified for .|DEFAULT| is used for any target for which no rules
    are found (either explicit rules or implicit rules). See Last Resort. If a
    .|DEFAULT| recipe is specified, every file mentioned as a prerequisite, but
    not as a target in a rule, will have that recipe executed on its behalf.
    See Implicit Rule Search Algorithm.

.*PRECIOUS*

    The targets which .|PRECIOUS| depends on are given the following special
    treatment: if make is killed or interrupted during the execution of their
    recipes, the target is not deleted. See Interrupting or Killing make. Also,
    if the target is an intermediate file, it will not be deleted after it is
    no longer needed, as is normally done. See Chains of Implicit Rules. In
    this latter respect it overlaps with the .|SECONDARY| special target.

    You can also list the target pattern of an implicit rule (such as ‘%.o’) as
    a prerequisite file of the special target .|PRECIOUS| to preserve
    intermediate files created by rules whose target patterns match that file’s
    name.

.*INTERMEDIATE*

    The targets which .|INTERMEDIATE| depends on are treated as intermediate
    files. See Chains of Implicit Rules. .|INTERMEDIATE| with no prerequisites
    has no effect.

.*SECONDARY*

    The targets which .|SECONDARY| depends on are treated as intermediate files,
    except that they are never automatically deleted. See Chains of Implicit
    Rules.

    .|SECONDARY| with no prerequisites causes all targets to be treated as
    secondary (i.e., no target is removed because it is considered
    intermediate).

.*SECONDEXPANSION*

    If .|SECONDEXPANSION| is mentioned as a target anywhere in the makefile, then
    all prerequisite lists defined after it appears will be expanded a second
    time after all makefiles have been read in. See Secondary Expansion.

.*DELETE_ON_ERROR*

    If .|DELETE_ON_ERROR| is mentioned as a target anywhere in the makefile, then
    make will delete the target of a rule if it has changed and its recipe
    exits with a nonzero exit status, just as it does when it receives a
    signal. See Errors in Recipes.

*.IGNORE*

    If you specify prerequisites for .|IGNORE|, then make will ignore errors in
    execution of the recipe for those particular files. The recipe for .|IGNORE|
    (if any) is ignored.

    If mentioned as a target with no prerequisites, .|IGNORE| says to ignore
    errors in execution of recipes for all files. This usage of ‘.|IGNORE|’ is
    supported only for historical compatibility. Since this affects every
    recipe in the makefile, it is not very useful; we recommend you use the
    more selective ways to ignore errors in specific recipes. See Errors in
    Recipes.

.*LOW_RESOLUTION_TIME*

    If you specify prerequisites for .|LOW_RESOLUTION_TIME|, make assumes that
    these files are created by commands that generate low resolution time
    stamps. The recipe for the .|LOW_RESOLUTION_TIME| target are ignored.

    The high resolution file time stamps of many modern file systems lessen the
    chance of make incorrectly concluding that a file is up to date.
    Unfortunately, some hosts do not provide a way to set a high resolution
    file time stamp, so commands like ‘cp -p’ that explicitly set a file’s time
    stamp must discard its sub-second part. If a file is created by such a
    command, you should list it as a prerequisite of .|LOW_RESOLUTION_TIME| so
    that make does not mistakenly conclude that the file is out of date. For
    example:

    .|LOW_RESOLUTION_TIME|: dst
    dst: src
            cp -p src dst

    Since ‘cp -p’ discards the sub-second part of src’s time stamp, dst is
    typically slightly older than src even when it is up to date. The
    .|LOW_RESOLUTION_TIME| line causes make to consider dst to be up to date if
    its time stamp is at the start of the same second that src’s time stamp is
    in.

    Due to a limitation of the archive format, archive member time stamps are
    always low resolution. You need not list archive members as prerequisites
    of .|LOW_RESOLUTION_TIME|, as make does this automatically.

.*SILENT*

    If you specify prerequisites for .|SILENT|, then make will not print the
    recipe used to remake those particular files before executing them. The
    recipe for .|SILENT| is ignored.

    If mentioned as a target with no prerequisites, .|SILENT| says not to print
    any recipes before executing them. This usage of ‘.|SILENT|’ is supported
    only for historical compatibility. We recommend you use the more selective
    ways to silence specific recipes. See Recipe Echoing. If you want to
    silence all recipes for a particular run of make, use the ‘-s’ or
    ‘--silent’ option (see Options Summary).

.*EXPORT_ALL_VARIABLES*

    Simply by being mentioned as a target, this tells make to export all
    variables to child processes by default. See Communicating Variables to a
    Sub-make.

.*NOTPARALLEL*

    If .|NOTPARALLEL| is mentioned as a target, then this invocation of make will
    be run serially, even if the ‘-j’ option is given. Any recursively invoked
    make command will still run recipes in parallel (unless its makefile also
    contains this target). Any prerequisites on this target are ignored.

.*ONESHELL*

    If .|ONESHELL| is mentioned as a target, then when a target is built all
    lines of the recipe will be given to a single invocation of the shell
    rather than each line being invoked separately (see Recipe Execution).

.*POSIX*

    If .|POSIX| is mentioned as a target, then the makefile will be parsed and
    run in POSIX-conforming mode. This does not mean that only POSIX-conforming
    makefiles will be accepted: all advanced GNU make features are still
    available. Rather, this target causes make to behave as required by POSIX
    in those areas where make’s default behavior differs.

    In particular, if this target is mentioned then recipes will be invoked as
    if the shell had been passed the -e flag: the first failing command in a
    recipe will cause the recipe to fail immediately. 

Any defined implicit rule suffix also counts as a special target if it appears
as a target, and so does the concatenation of two suffixes, such as ‘.c.o’.
These targets are suffix rules, an obsolete way of defining implicit rules (but
a way still widely used). In principle, any target name could be special in
this way if you break it in two and add both pieces to the suffix list. In
practice, suffixes normally begin with ‘.’, so these special target names also
begin with ‘.’. See Old-Fashioned Suffix Rules. 

## vim:tw=78:ts=8:ft=help:norl:
